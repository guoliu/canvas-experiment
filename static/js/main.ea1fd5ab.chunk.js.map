{"version":3,"sources":["components/Canvas.jsx","components/Animation.jsx","serviceWorker.js","index.js","App.js"],"names":["clear","canvas","width","height","getContext","clearRect","Canvas","_ref","particles","lines","setClientPos","canvasRef","useRef","_useState","useState","_useState2","Object","slicedToArray","darkMode","setDarkMode","useEffect","current","addEventListener","e","clientX","clientY","stopPropagation","preventDefault","ctx","map","_ref2","radius","position","beginPath","arc","Math","PI","lineWidth","strokeStyle","stroke","_ref3","start","end","strength","moveTo","lineTo","concat","useMemo","react_default","a","createElement","window","innerWidth","innerHeight","ref","onClick","Animation","angle","Array","fill","_ref$speed","speed","_ref$repulsion","repulsion","_ref$attraction","attraction","_ref$connectSize","connectSize","random","direction","update","_this","this","_ref2$particles","index","clientPos","forEach","p","pIndex","vector2peer","distance","sqrt","force","push","vector2client","distance2client","attractionForce","capRate","particle","createParticle","state","setState","_useState3","_useState4","animationFrameId","requestAnimationFrame","_particle$update","newParticle","newLines","objectSpread","cancelAnimationFrame","Boolean","location","hostname","match","ReactDOM","render","style","padding","margin","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"+KAEMA,EAAQ,SAAAC,GAAU,IACdC,EAAkBD,EAAlBC,MAAOC,EAAWF,EAAXE,OACHF,EAAOG,WAAW,MAC1BC,UAAU,EAAG,EAAGH,EAAOC,IAGdG,EAAA,SAAAC,GAAwC,IAArCC,EAAqCD,EAArCC,UAAWC,EAA0BF,EAA1BE,MAAOC,EAAmBH,EAAnBG,aAC5BC,EAAYC,iBAAO,MAD4BC,EAErBC,oBAAS,GAFYC,EAAAC,OAAAC,EAAA,EAAAD,CAAAH,EAAA,GAE9CK,EAF8CH,EAAA,GAEpCI,EAFoCJ,EAAA,GAkErD,OA7DAK,oBAAU,WACR,IAAMnB,EAASU,EAAUU,QACjBnB,EAAkBD,EAAlBC,MAAOC,EAAWF,EAAXE,OACXF,IACFA,EAAOqB,iBAAiB,YAAa,SAASC,GAC5Cb,EAAa,CAACa,EAAEC,QAAUtB,EAAOqB,EAAEE,QAAUtB,MAG/CF,EAAOqB,iBACL,YACA,SAASC,GAEPA,EAAEG,kBACFH,EAAEI,iBAEFjB,EAAa,CAACa,EAAEC,QAAUtB,EAAOqB,EAAEE,QAAUtB,MAE/C,KAGH,CAACQ,EAAWD,EAAcQ,IAG7BE,oBAAU,WACR,IAAMnB,EAASU,EAAUU,QACjBnB,EAAkBD,EAAlBC,MAAOC,EAAWF,EAAXE,OACTyB,EAAM3B,EAAOG,WAAW,MAEzBc,IACHlB,EAAMC,GACNO,EAAUqB,IAAI,SAAAC,GAA0B,IAAvBC,EAAuBD,EAAvBC,OAAQC,EAAeF,EAAfE,SAavB,OAZAJ,EAAIK,YACJL,EAAIM,IACFF,EAAS,GAAK9B,EACd8B,EAAS,GAAK7B,EACd4B,EAAS5B,EACT,EACA,EAAIgC,KAAKC,IACT,GAEFR,EAAIS,UAAY,EAChBT,EAAIU,YAAc,UAClBV,EAAIW,UACG,KAIX9B,EAAMoB,IAAI,SAAAW,GAA8B,IAA3BC,EAA2BD,EAA3BC,MAAOC,EAAoBF,EAApBE,IAAKC,EAAeH,EAAfG,SAUvB,OATAf,EAAIK,YACJL,EAAIgB,OAAOH,EAAM,GAAKvC,EAAOuC,EAAM,GAAKtC,GACxCyB,EAAIiB,OAAOH,EAAI,GAAKxC,EAAOwC,EAAI,GAAKvC,GACpCyB,EAAIS,UAAYM,EAAW,EACvBzB,IACFU,EAAIU,YAAJ,QAAAQ,OAAqC,IAAXH,EAA1B,MAAAG,OACE,IAD2CH,EAA7C,MAAAG,OACqB,IAAXH,EADV,WAGFf,EAAIW,UACG,KAER,CAAC/B,EAAWC,EAAOS,IAEf6B,kBACL,kBACEC,EAAAC,EAAAC,cAAA,UACEhD,MAAOiD,OAAOC,WACdjD,OAAQgD,OAAOE,YACfC,IAAK3C,EACL4C,QAAS,SAAAhC,GACPA,EAAEG,kBACFP,EAAY,SAAAD,GAIV,OAHKA,GACHlB,EAAMW,EAAUU,UAEVH,QAKhB,CAACiC,OAAOC,WAAYD,OAAOE,YAAanC,KCO7BsC,EAAA,WAAM,IAAA3C,EACOC,mBAAS,CACjC2C,MAAO,EACPjD,UAAWkD,MAAM,IACdC,OACA9B,IAAI,kBApGY,SAAAtB,GAAA,IAAAqD,EAAArD,EACrBsD,aADqB,IAAAD,EACb,KADaA,EAAAE,EAAAvD,EAErBwD,iBAFqB,IAAAD,EAET,KAFSA,EAAAE,EAAAzD,EAGrB0D,kBAHqB,IAAAD,EAGR,MAHQA,EAAAE,EAAA3D,EAIrB4D,mBAJqB,IAAAD,EAIP,IAJOA,EAAA,MAKhB,CACLnC,OAAQ,KACRC,SAAU,CAACG,KAAKiC,SAAUjC,KAAKiC,UAC/BC,UAAW,CAAClC,KAAKiC,SAAWP,EAAO1B,KAAKiC,SAAWP,GACnDS,OAJK,SAAAxC,GAIwC,IAAAyC,EAAAC,KAAAC,EAAA3C,EAApCtB,iBAAoC,IAAAiE,EAAxB,GAAwBA,EAApBC,EAAoB5C,EAApB4C,MAAOC,EAAa7C,EAAb6C,UAE9BH,KAAKxC,SAAW,CACdwC,KAAKxC,SAAS,GAAKwC,KAAKH,UAAU,GAClCG,KAAKxC,SAAS,GAAKwC,KAAKH,UAAU,IAGpC,IAAM5D,EAAQ,GACdD,EAAUoE,QAAQ,SAACC,EAAGC,GAEpB,GAAIA,IAAWJ,EAAO,CAEpB,IAAMK,EAAc,CAClBF,EAAE7C,SAAS,GAAKuC,EAAKvC,SAAS,GAC9B6C,EAAE7C,SAAS,GAAKuC,EAAKvC,SAAS,IAE1BgD,EAAW7C,KAAK8C,KACpBF,EAAY,GAAKA,EAAY,GAAKA,EAAY,GAAKA,EAAY,IAK3DG,EAAQ,CACTnB,GAAagB,EAAY,IAAOC,EAAWA,GAC3CjB,GAAagB,EAAY,IAAOC,EAAWA,IAG9CT,EAAKF,UAAY,CACfE,EAAKF,UAAU,GAAKa,EAAM,GAC1BX,EAAKF,UAAU,GAAKa,EAAM,IAK1BJ,EAASJ,GAASM,EAAWb,GAC/B1D,EAAM0E,KAAK,CACT1C,MAAO8B,EAAKvC,SACZU,IAAKmC,EAAE7C,SACPW,SAAU,EAAIqC,EAAWb,OAOjC,IAAMiB,EAAgB,CACpBT,EAAU,GAAKH,KAAKxC,SAAS,GAC7B2C,EAAU,GAAKH,KAAKxC,SAAS,IAGzBqD,EAAkBlD,KAAK8C,KAC3BG,EAAc,GAAKA,EAAc,GAAKA,EAAc,GAAKA,EAAc,IAIrEC,EAAkBlB,GACpB1D,EAAM0E,KAAK,CACT1C,MAAO+B,KAAKxC,SACZU,IAAKiC,EACLhC,SAAU,EAAI0C,EAAkBlB,IAKpC,IAAMmB,EAAkB,CACtBrB,EAAamB,EAAc,GAAKC,EAAkBA,EAClDpB,EAAamB,EAAc,GAAKC,EAAkBA,GAGpDb,KAAKH,UAAY,CACfG,KAAKH,UAAU,GAAKiB,EAAgB,GACpCd,KAAKH,UAAU,GAAKiB,EAAgB,IAItC,IAAMC,EACJpD,KAAK8C,KACHT,KAAKH,UAAU,GAAKG,KAAKH,UAAU,GACjCG,KAAKH,UAAU,GAAKG,KAAKH,UAAU,IACnCR,EAGN,OAFAW,KAAKH,UAAY,CAACG,KAAKH,UAAU,GAAKkB,EAASf,KAAKH,UAAU,GAAKkB,GAE5D,CAAEC,SAAUhB,KAAM/D,WASZgF,CAAe,MAC5BhF,MAAO,KANUM,EAAAC,OAAAC,EAAA,EAAAD,CAAAH,EAAA,GACZ6E,EADY3E,EAAA,GACL4E,EADK5E,EAAA,GAAA6E,EASe9E,mBAAS,CAAC,GAAK,KAT9B+E,EAAA7E,OAAAC,EAAA,EAAAD,CAAA4E,EAAA,GASZjB,EATYkB,EAAA,GASDnF,EATCmF,EAAA,GAsCnB,OA3BAzE,oBAAU,WACR,IAsBI0E,EAAmBC,sBAtBM,WAC3B,IAAIvF,EAAY,GACZC,EAAQ,GAEZiF,EAAMlF,UAAUqB,IAAI,SAAC2D,EAAUd,GAAU,IAAAsB,EACYR,EAASlB,OAAO,CACjEI,QACAlE,UAAWkF,EAAMlF,UACjBmE,cAHgBsB,EADqBD,EAC/BR,SAA8BU,EADCF,EACRvF,MAQ/B,OAFAD,EAAU2E,KAAKc,GACfxF,EAAQA,EAAMqC,OAAOoD,IACd,IAGTP,EAAS,SAAAD,GAAK,OAAA1E,OAAAmF,EAAA,EAAAnF,CAAA,GACT0E,EADS,CAEZlF,YACAC,cAIJ,OAAO,kBAAM2F,qBAAqBN,KACjC,CAACJ,EAAOf,IAGT3B,EAAAC,EAAAC,cAAC5C,EAAD,CACEG,MAAOiF,EAAMjF,MACbD,UAAWkF,EAAMlF,UACjBE,aAAcA,KChIA2F,QACW,cAA7BlD,OAAOmD,SAASC,UAEe,UAA7BpD,OAAOmD,SAASC,UAEhBpD,OAAOmD,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP1D,EAAAC,EAAAC,cCHa,kBAAMF,EAAAC,EAAAC,cAACM,EAAD,ODGnB,CAAKmD,MAAO,CAAEzG,MAAO,OAAQC,OAAQ,OAAQyG,QAAS,EAAGC,OAAQ,KACjEC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.ea1fd5ab.chunk.js","sourcesContent":["import React, { useEffect, useMemo, useRef, useState } from \"react\"\n\nconst clear = canvas => {\n  const { width, height } = canvas\n  const ctx = canvas.getContext(\"2d\")\n  ctx.clearRect(0, 0, width, height)\n}\n\nexport default ({ particles, lines, setClientPos }) => {\n  const canvasRef = useRef(null)\n  const [darkMode, setDarkMode] = useState(false)\n\n  // setup\n  useEffect(() => {\n    const canvas = canvasRef.current\n    const { width, height } = canvas\n    if (canvas) {\n      canvas.addEventListener(\"mousemove\", function(e) {\n        setClientPos([e.clientX / width, e.clientY / height])\n      })\n\n      canvas.addEventListener(\n        \"touchmove\",\n        function(e) {\n          // stop touch event\n          e.stopPropagation()\n          e.preventDefault()\n\n          setClientPos([e.clientX / width, e.clientY / height])\n        },\n        false\n      )\n    }\n  }, [canvasRef, setClientPos, darkMode])\n\n  // render\n  useEffect(() => {\n    const canvas = canvasRef.current\n    const { width, height } = canvas\n    const ctx = canvas.getContext(\"2d\")\n\n    if (!darkMode) {\n      clear(canvas)\n      particles.map(({ radius, position }) => {\n        ctx.beginPath()\n        ctx.arc(\n          position[0] * width,\n          position[1] * height,\n          radius * height,\n          0,\n          2 * Math.PI,\n          false\n        )\n        ctx.lineWidth = 1\n        ctx.strokeStyle = \"#000000\"\n        ctx.stroke()\n        return false\n      })\n    }\n\n    lines.map(({ start, end, strength }) => {\n      ctx.beginPath()\n      ctx.moveTo(start[0] * width, start[1] * height)\n      ctx.lineTo(end[0] * width, end[1] * height)\n      ctx.lineWidth = strength / 2\n      if (darkMode) {\n        ctx.strokeStyle = `rgba(${strength * 255}, ${strength *\n          255}, ${strength * 255}, 0.3)`\n      }\n      ctx.stroke()\n      return false\n    })\n  }, [particles, lines, darkMode])\n\n  return useMemo(\n    () => (\n      <canvas\n        width={window.innerWidth}\n        height={window.innerHeight}\n        ref={canvasRef}\n        onClick={e => {\n          e.stopPropagation()\n          setDarkMode(darkMode => {\n            if (!darkMode) {\n              clear(canvasRef.current)\n            }\n            return !darkMode\n          })\n        }}\n      />\n    ),\n    [window.innerWidth, window.innerHeight, darkMode]\n  )\n}\n","import React, { useState, useEffect } from \"react\"\nimport Canvas from \"./Canvas\"\n\nconst createParticle = ({\n  speed = 0.005,\n  repulsion = 0.000005,\n  attraction = 0.0015,\n  connectSize = 0.25\n}) => ({\n  radius: 0.002,\n  position: [Math.random(), Math.random()],\n  direction: [Math.random() * speed, Math.random() * speed],\n  update({ particles = [], index, clientPos }) {\n    // update position\n    this.position = [\n      this.position[0] + this.direction[0],\n      this.position[1] + this.direction[1]\n    ]\n\n    const lines = []\n    particles.forEach((p, pIndex) => {\n      // skip self\n      if (pIndex !== index) {\n        // get distance and vector\n        const vector2peer = [\n          p.position[0] - this.position[0],\n          p.position[1] - this.position[1]\n        ]\n        const distance = Math.sqrt(\n          vector2peer[0] * vector2peer[0] + vector2peer[1] * vector2peer[1]\n        )\n\n        // calculate repulsion\n        if (true) {\n          let force = [\n            (repulsion * -vector2peer[0]) / (distance * distance),\n            (repulsion * -vector2peer[1]) / (distance * distance)\n          ]\n\n          this.direction = [\n            this.direction[0] + force[0],\n            this.direction[1] + force[1]\n          ]\n        }\n\n        // form new lines\n        if (pIndex > index && distance < connectSize) {\n          lines.push({\n            start: this.position,\n            end: p.position,\n            strength: 1 - distance / connectSize\n          })\n        }\n      }\n    })\n\n    // get client distance\n    const vector2client = [\n      clientPos[0] - this.position[0],\n      clientPos[1] - this.position[1]\n    ]\n\n    const distance2client = Math.sqrt(\n      vector2client[0] * vector2client[0] + vector2client[1] * vector2client[1]\n    )\n\n    // line to client\n    if (distance2client < connectSize) {\n      lines.push({\n        start: this.position,\n        end: clientPos,\n        strength: 1 - distance2client / connectSize\n      })\n    }\n\n    // calculate attraction\n    const attractionForce = [\n      attraction * vector2client[0] * distance2client * distance2client,\n      attraction * vector2client[1] * distance2client * distance2client\n    ]\n\n    this.direction = [\n      this.direction[0] + attractionForce[0],\n      this.direction[1] + attractionForce[1]\n    ]\n\n    // cap direction\n    const capRate =\n      Math.sqrt(\n        this.direction[0] * this.direction[0] +\n          this.direction[1] * this.direction[1]\n      ) / speed\n    this.direction = [this.direction[0] / capRate, this.direction[1] / capRate]\n\n    return { particle: this, lines }\n  }\n})\n\nexport default () => {\n  const [state, setState] = useState({\n    angle: 0,\n    particles: Array(30)\n      .fill()\n      .map(() => createParticle({})),\n    lines: []\n  })\n\n  const [clientPos, setClientPos] = useState([0.5, 0.5])\n\n  useEffect(() => {\n    const updateAnimationState = () => {\n      let particles = []\n      let lines = []\n\n      state.particles.map((particle, index) => {\n        const { particle: newParticle, lines: newLines } = particle.update({\n          index,\n          particles: state.particles,\n          clientPos\n        })\n\n        particles.push(newParticle)\n        lines = lines.concat(newLines)\n        return false\n      })\n\n      setState(state => ({\n        ...state,\n        particles,\n        lines\n      }))\n    }\n    let animationFrameId = requestAnimationFrame(updateAnimationState)\n    return () => cancelAnimationFrame(animationFrameId)\n  }, [state, clientPos])\n\n  return (\n    <Canvas\n      lines={state.lines}\n      particles={state.particles}\n      setClientPos={setClientPos}\n    />\n  )\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport \"./index.css\"\nimport App from \"./App\"\nimport * as serviceWorker from \"./serviceWorker\"\n\nReactDOM.render(\n  <App style={{ width: \"100%\", height: \"100%\", padding: 0, margin: 0 }} />,\n  document.getElementById(\"root\")\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n","import React from \"react\"\n\nimport Animation from \"./components/Animation\"\n\nexport default () => <Animation />\n"],"sourceRoot":""}